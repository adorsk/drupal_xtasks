<?php

define('XTASKS_UPDATE_EP', 'xtasks/update_task');
define('XTASKS_STATUS_EP', 'xtasks/task_status');

/**
 * Implements hook_menu().
 */
function xtasks_menu(){
  $items[XTASKS_UPDATE_EP] = array(
    'title' => 'XTasks Update Endpoint',
    'access callback' => TRUE,
    'page callback' => 'xtasks_update_task_ep',
    'page arguments' => array(2),
    'type' => MENU_CALLBACK,
  );

  $items[XTASKS_STATUS_EP] = array(
    'title' => 'XTasks Task Status',
    'access callback' => TRUE, // @TODO! CHANGE THIS LATER...
    'page callback' => '_xtasks_task_status_page',
    'page arguments' => array(2),
    'type' => MENU_CALLBACK,
  );
  return $items;
}

/**
 * Implements hook_node_info().
 */
function xtasks_node_info(){
  return array(
    'xtask' => array(
      'name' => t('XTask'),
      'base' => 'xtask',
      'description' => t('An external task. Contains metadata for running the task, and the state of the task.'),
    )
  );
}

/**
 * Handles result of post to update task endpoint.
 * $task_token is an access token corresponding to
 * a specific task. The token is the method of access
 * control. The token is generated when a task is created.
 */
function xtasks_update_task_ep($token){
  if (! $token){
    return MENU_NOT_FOUND;
  }

  // Get task corresponding to token.
  $token_record = db_query(
    "SELECT token, nid FROM {xtasks_tokens} WHERE token = :token",
    array(':token' => $token))->fetchObject();

  if (! $token_record){
    return MENU_NOT_FOUND;
  }

  // Parse posted data.
  try{
    $json_data = file_get_contents("php://input");
    $data = json_decode($json_data, true);
  }
  catch (Exception $e){
    // Do 400 Error here.
  }

  // Update task with posted data.
  $node = node_load($token_record->nid);
  if (! $node){
    return MENU_NOT_FOUND;
  }
  $field_attrs = array('status', 'data');
  foreach($field_attrs as $field_attr){
    if (array_key_exists($field_attr, $data)){
      $node->{"xtasks_$field_attr"} = array(
        LANGUAGE_NONE => array(
          array('value' => $data[$field_attr])
        )
      );
    }
  }

  // If task status is resolved or rejected, remove token.
  $status = $node->xtasks_status[LANGUAGE_NONE][0]['value'];
  if ($status == 'completed' || $status == 'failed'){
    db_delete('xtasks_tokens')
      ->condition('token', $token)
      ->execute();
    unset($node->xtasks_token[LANGUAGE_NONE][0]['value']);
  }

  node_save($node);

  drupal_json_output(array());
  drupal_exit();
}

/**
 * Implements hook_insert().
 * Creates access token for task.
 */
function xtask_insert($node){
  $token = uniqid('task' . $node->nid);
  db_insert('xtasks_tokens') ->fields(array(
    'token' => $token,
    'nid' => $node->nid
  ))->execute();

  $node->xtasks_token['und'][0]['value'] = $token;
}

/**
 * Implements hook_form().
 */
function xtask_form($node, $form_state){
  return node_content_form($node, $form_state);
}

/**
 * Implements hook_form_alter().
 *
 * Hides the token field.
 */
function xtasks_form_xtasks_node_form_alter(&$form, $form_state, $form_id) {
  unset($form['xtasks_token']);
}

/**
 * Runs a task.
 */
function xtasks_run_task($nid){
  $node = node_load($nid);
  if (! $node){
    // HANDLE ERROR HERE.
  }

  // Get array representation of task.
  $task = xtasks_task_to_array($node);

  // Get command from task config.
  $cmd = $task['config']['command'];

  // Run the command and pass it the task as a JSON string via stdin.
  $json_task = json_encode($task);
  $proc = proc_open($cmd, array(array("pipe", "r")), $pipes);
  if (is_resource($proc)){
    fwrite($pipes[0], $json_task);
    fclose($pipes[0]);
    $ret = proc_close($proc);
    if ($ret != 0){
      // HANDLE ERROR.
    }
  }
  else{
    // HANDLE ERROR.
  }

}

/**
 * Get an array representing a task.
 */
function xtasks_task_to_array($node){
  $task_array = array();
  $task_attrs = array('data', 'status', 'config');
  foreach ($task_attrs as $task_attr){
    $field = $node->{"xtasks_$task_attr"};
    $value = $field[LANGUAGE_NONE][0]['value'];
    if ($value){
      $value = json_decode($value, true);
    }
    else{
      $value = array();
    }
    $task_array[$task_attr] = $value;
  }
  // Add update endpoint to config.
  $token = $node->xtasks_token[LANGUAGE_NONE][0]['value'];
  $task_array['config']['update_url'] = url(
    XTASKS_UPDATE_EP . "/$token", array('absolute' => TRUE));

  // Add task id.
  $task_array['id'] = $node->nid;

  return $task_array;
}

/**
 * View status of a task.
 */
function _xtasks_task_status_page($nid){
  $node = node_load($nid);
  if (! $node){
    return MENU_NOT_FOUND;
  }
  $status_field = $node->xtasks_status;
  $status = null;
  if ($status_field){
    $status = $status_field[LANGUAGE_NONE][0]['value'];
  }
  $task_progress_field = $node->xtasks_progress;
  $task_progress = null;
  if ($task_progress_field){
    $task_progress = $task_progress_field[LANGUAGE_NONE][0]['value'];
  }

  if (
    $status == 'resolved' || $status == 'failed'
    || $task_progress >= 100
  ){
    return _xtasks_task_status_finished_page($nid);
  }
  else{
    // Get or create batch job for monitoring the task.
    $batch_record = db_query(
    "SELECT bid, nid FROM {xtasks_batch} WHERE nid= :nid",
    array(':nid' => $nid))->fetchObject();

    $bid = null;
    if (empty($batch_record)){
      // Initialize operations w/ init op.
      $operations = array(
        array('_xtasks_monitor_batch_init', array($nid)),
      );
      // Add operations to represent completion for 1-100%.
      // This is a trick to report on task progress.
      for ($i = 1; $i < 100; $i++){
        $operations[] = array('_xtasks_monitor_batch_op', array($i));
      }

      $batch_def = array(
        'operations' => $operations,
        'finished' => '_xtasks_monitor_batch_finished',
      );
      batch_set($batch_def);
      $batch = batch_get();
      batch_process();
      return;
    }
    else{
      $bid = $batch_record->bid;
    }
    drupal_goto('batch', array(
      'query' => array(
        'op' => 'start',
        'id' => $batch_record->bid
      )));
    return;
  }
}

function _xtasks_monitor_batch_init($nid, &$context){
  $batch = batch_get();

  db_insert('xtasks_batch') ->fields(array(
    'bid' => $batch['id'],
    'nid' => $nid
  ))->execute();

  $context['results']['bid'] = $batch['id'];
  $context['message'] = 'Started task monitoring...';
  $context['results']['task_nid'] = $nid;
  $context['finished'] = 1;
}

function _xtasks_monitor_batch_op($op_progress, &$context){
  // Get task data.
  $nid = $context['results']['task_nid'];
  $node = node_load($nid);
  if (! $node){
    throw new Exception("Could not load task with id '$nid'");
  }

  $task_progress = $node->xtasks_progress[LANGUAGE_NONE][0]['value'];
  $status = $node->xtasks_status[LANGUAGE_NONE][0]['value'];
  $message = $node->xtasks_message[LANGUAGE_NONE][0]['value'];

  if (! $task_progress){
    $task_progress = 0;
    if (! $message){
      $message = t("Waiting for task to begin...");
    }
  }

  if (! is_numeric($task_progress)){
    throw new Exception("Invalid value for task progress. Value was '$task_progress'");
  }

  // Skip to the end if resolved or rejected.
  if ($status == 'resolved' || $status == 'rejected'){
    $node->xtasks_progress[LANGUAGE_NONE][0]['value'] = 100;
  }

  if ($op_progress < $task_progress){

    // If skipping, return w/out setting message.
    if ($context['results']['skip']){
      $context['finished'] = 1;
      return;
    }
    // Otherwise start skipping.
    if (! $context['results']['skip']){
      $context['results']['skip'] = TRUE;
      $cur_progress = $op_progress;
      while ($cur_progress < $task_progress){
        list($progress, $message) = _batch_process();
        $cur_progress = $progress;
      }
      $context['results']['skip'] = FALSE;
    }
  }

  // Wait for task to catch up before moving to next op.
  // Set message.
  $context['message'] = $message;
  $context['finished'] = 0;
}

function _xtasks_monitor_batch_finished($success, $results, $ops){
  $nid = $results['task_nid'];
  $node = node_load($nid);

  // Remove xtask_batch record
  db_delete('xtasks_batch')
      ->condition('bid', $results['bid'])
      ->execute();

  if ($success) {
    $message = "Task finished successfully.";
  }
  else {
    $message = t('Task did not finish successfully. There was an error.');
  }
  drupal_set_message($message);

  // Providing data for the redirected page is done through $_SESSION.
  $_SESSION['task_data'] = array();

  drupal_goto(XTASKS_STATUS_EP . "/$nid");
}

function _xtasks_task_status_finished_page($node){
  return "it's done!";
}
